from typing import Any, Optional, List, Dict
from smolagents.tools import Tool
from datetime import datetime
from pathlib import Path

class SecuritySummaryTool(Tool):
    name = "security_summary"
    description = "Generates comprehensive security reports from vulnerability scan results, reputation analysis, and dependency chain data. Creates formatted markdown reports with executive summaries and detailed findings."
    inputs = {
        'scan_results': {'type': 'string', 'description': 'JSON string containing security scan results for one or more packages, including vulnerabilities, reputation data, and dependency information.'},
        'report_title': {'type': 'string', 'description': 'Optional title for the security report. If not provided, will be auto-generated.', 'required': False, 'nullable': True},
        'include_remediation': {'type': 'boolean', 'description': 'Whether to include detailed remediation steps in the report. Default is True.', 'required': False, 'nullable': True}
    }
    output_type = "string"

    def __init__(self, **kwargs):
        super().__init__()
        
        # Check optional dependencies
        try:
            import json
            from datetime import datetime
        except ImportError as e:
            raise ImportError(
                "Standard library modules required for this tool are missing."
            ) from e

    def forward(self, scan_results: str, report_title: Optional[str] = None, 
               include_remediation: bool = True) -> str:
        """
        Generate a comprehensive security report from scan results.
        
        Args:
            scan_results: JSON string containing security scan results
            report_title: Optional custom title for the report
            include_remediation: Whether to include remediation steps
            
        Returns:
            Formatted markdown security report
        """
        try:
            # Parse scan results
            import json
            if isinstance(scan_results, str):
                parsed_results = json.loads(scan_results)
            else:
                parsed_results = scan_results
            
            # Ensure we have a list of results
            if not isinstance(parsed_results, list):
                parsed_results = [parsed_results]
            
            return self._generate_security_report(parsed_results, report_title, include_remediation)
        except Exception as e:
            return f"Error generating security report: {str(e)}"

    def _generate_security_report(self, scan_results: List[Dict], report_title: Optional[str] = None, 
                                 include_remediation: bool = True) -> str:
        """Generate a comprehensive security report from scan results."""
        # Initialize report
        report = []
        
        # Add header
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        if report_title:
            title = report_title
        elif len(scan_results) == 1:
            title = f"Security Analysis: {scan_results[0].get('package', 'Unknown Package')}"
        else:
            title = f"Security Analysis: {len(scan_results)} Packages"
        
        report.append(f"# {title}\n")
        report.append(f"**Generated:** {timestamp}\n")
        
        # Generate executive summary
        summary = self._generate_executive_summary(scan_results)
        report.append(summary)
        
        # Add detailed findings
        findings = self._generate_detailed_findings(scan_results, include_remediation)
        report.append(findings)
        
        # Add recommendations
        recommendations = self._generate_recommendations(scan_results)
        report.append(recommendations)
        
        # Add footer
        report.append("\n---")
        report.append("\n*This report was generated by the Python Security Analysis Assistant*")
        
        return "\n".join(report)

    def _generate_executive_summary(self, scan_results: List[Dict]) -> str:
        """Generate executive summary section."""
        summary = ["## üìä Executive Summary\n"]
        
        # Count total vulnerabilities and categorize by severity
        total_vulnerabilities = 0
        critical = 0
        high = 0
        medium = 0
        low = 0
        unknown = 0
        vulnerable_packages = []
        total_packages = len(scan_results)
        
        for result in scan_results:
            vulns = result.get('vulnerabilities', [])
            if vulns:
                vulnerable_packages.append(result)
                total_vulnerabilities += len(vulns)
                for vuln in vulns:
                    severity = vuln.get('severity', 'Unknown')
                    if severity == 'Critical': critical += 1
                    elif severity == 'High': high += 1
                    elif severity == 'Medium': medium += 1
                    elif severity == 'Low': low += 1
                    else: unknown += 1
        
        # Overall risk assessment
        if critical > 0:
            risk_level = "üö® **CRITICAL RISK**"
            summary.append(f"{risk_level} - Immediate action required\n")
        elif high > 0:
            risk_level = "üî¥ **HIGH RISK**"
            summary.append(f"{risk_level} - Urgent attention needed\n")
        elif medium > 0:
            risk_level = "üü° **MEDIUM RISK**"
            summary.append(f"{risk_level} - Should be addressed\n")
        elif low > 0:
            risk_level = "üîµ **LOW RISK**"
            summary.append(f"{risk_level} - Minor issues found\n")
        else:
            risk_level = "‚úÖ **LOW RISK**"
            summary.append(f"{risk_level} - No vulnerabilities detected\n")
        
        # Key metrics
        summary.append("### Key Metrics\n")
        summary.append(f"- **Packages Analyzed:** {total_packages}")
        summary.append(f"- **Vulnerable Packages:** {len(vulnerable_packages)}")
        summary.append(f"- **Total Vulnerabilities:** {total_vulnerabilities}")
        
        if total_vulnerabilities > 0:
            summary.append(f"- **Critical:** {critical}")
            summary.append(f"- **High:** {high}")
            summary.append(f"- **Medium:** {medium}")
            summary.append(f"- **Low:** {low}")
            if unknown > 0:
                summary.append(f"- **Unknown:** {unknown}")
        
        summary.append("")
        
        # Reputation and dependency insights
        reputation_issues = 0
        dependency_issues = 0
        
        for result in scan_results:
            # Check reputation issues
            reputation = result.get('reputation', {})
            if reputation.get('risk_level') in ['High', 'Medium']:
                reputation_issues += 1
            
            # Check dependency issues
            dependencies = result.get('dependencies', {})
            if dependencies.get('vulnerable_dependency_count', 0) > 0:
                dependency_issues += 1
        
        if reputation_issues > 0 or dependency_issues > 0:
            summary.append("### Additional Concerns\n")
            if reputation_issues > 0:
                summary.append(f"- **Reputation Issues:** {reputation_issues} packages have reputation concerns")
            if dependency_issues > 0:
                summary.append(f"- **Dependency Issues:** {dependency_issues} packages have vulnerable dependencies")
            summary.append("")
        
        return "\n".join(summary)

    def _generate_detailed_findings(self, scan_results: List[Dict], include_remediation: bool) -> str:
        """Generate detailed findings section."""
        findings = ["## üîç Detailed Findings\n"]
        
        for i, result in enumerate(scan_results, 1):
            package_name = result.get('package', f'Package {i}')
            package_version = result.get('version', 'Unknown')
            
            findings.append(f"### {i}. {package_name} (v{package_version})\n")
            
            # Vulnerability analysis
            vulnerabilities = result.get('vulnerabilities', [])
            if vulnerabilities:
                findings.extend(self._format_vulnerability_section(vulnerabilities, include_remediation, package_name))
            else:
                findings.append("‚úÖ **No vulnerabilities found**\n")
            
            # Reputation analysis
            reputation = result.get('reputation', {})
            if reputation:
                findings.extend(self._format_reputation_section(reputation))
            
            # Dependency analysis
            dependencies = result.get('dependencies', {})
            if dependencies:
                findings.extend(self._format_dependency_section(dependencies))
            
            findings.append("---\n")
        
        return "\n".join(findings)

    def _format_vulnerability_section(self, vulnerabilities: List[Dict], include_remediation: bool, package_name: str) -> List[str]:
        """Format vulnerability information for a package."""
        section = []
        
        section.append(f"#### üö® Vulnerabilities ({len(vulnerabilities)} found)\n")
        
        # Sort vulnerabilities by severity
        severity_order = {"Critical": 0, "High": 1, "Medium": 2, "Low": 3, "Unknown": 4}
        sorted_vulns = sorted(
            vulnerabilities,
            key=lambda v: severity_order.get(v.get('severity', 'Unknown'), 5)
        )
        
        for vuln in sorted_vulns[:5]:  # Show top 5 vulnerabilities
            severity = vuln.get('severity', 'Unknown')
            vuln_id = vuln.get('id') or vuln.get('cve_id') or "No ID"
            
            # Severity emoji
            emoji = {
                'Critical': 'üö®', 'High': 'üî¥', 'Medium': 'üü°', 
                'Low': 'üîµ', 'Unknown': '‚ö™'
            }.get(severity, '‚ùì')
            
            section.append(f"**{emoji} {vuln_id}** ({severity})")
            
            summary_text = vuln.get('summary', 'No summary available')
            if len(summary_text) > 150:
                summary_text = summary_text[:147] + "..."
            section.append(f"- {summary_text}")
            
            if vuln.get('fixed_versions'):
                section.append(f"- **Fixed in:** {', '.join(vuln['fixed_versions'][:3])}")
            
            section.append("")
        
        if len(vulnerabilities) > 5:
            section.append(f"*... and {len(vulnerabilities) - 5} more vulnerabilities*\n")
        
        # Remediation
        if include_remediation:
            section.extend(self._generate_remediation_steps(vulnerabilities, package_name))
        
        return section

    def _format_reputation_section(self, reputation: Dict) -> List[str]:
        """Format reputation analysis section."""
        section = []
        
        risk_level = reputation.get('risk_level', 'Unknown')
        if risk_level in ['High', 'Medium']:
            emoji = 'üî¥' if risk_level == 'High' else 'üü°'
            section.append(f"#### {emoji} Reputation Analysis\n")
            
            section.append(f"**Risk Level:** {risk_level}")
            section.append(f"**Reputation Score:** {reputation.get('reputation_score', 'Unknown')}/10")
            
            suspicious_patterns = reputation.get('suspicious_patterns', [])
            if suspicious_patterns:
                section.append("**Concerns:**")
                for pattern in suspicious_patterns[:3]:
                    section.append(f"- {pattern}")
            
            section.append(f"**Package Age:** {reputation.get('package_age', 'Unknown')}")
            section.append(f"**Downloads:** {reputation.get('download_count', 'Unknown')}")
            section.append("")
        else:
            section.append("#### ‚úÖ Reputation Analysis\n")
            section.append("No significant reputation concerns identified.\n")
        
        return section

    def _format_dependency_section(self, dependencies: Dict) -> List[str]:
        """Format dependency analysis section."""
        section = []
        
        total_deps = dependencies.get('total_dependencies', 0)
        vulnerable_deps = dependencies.get('vulnerable_dependency_count', 0)
        total_vulns = dependencies.get('total_vulnerability_count', 0)
        
        if vulnerable_deps > 0:
            section.append(f"#### ‚ö†Ô∏è Dependency Analysis\n")
            section.append(f"**Total Dependencies:** {total_deps}")
            section.append(f"**Vulnerable Dependencies:** {vulnerable_deps}")
            section.append(f"**Total Vulnerabilities in Dependencies:** {total_vulns}")
            
            vulnerable_dependency_info = dependencies.get('vulnerable_dependencies', {})
            if vulnerable_dependency_info:
                section.append("\n**Top Vulnerable Dependencies:**")
                for dep_name, dep_info in list(vulnerable_dependency_info.items())[:3]:
                    vuln_count = dep_info.get('vulnerability_count', 0)
                    section.append(f"- **{dep_name}** ({vuln_count} vulnerabilities)")
                
                if len(vulnerable_dependency_info) > 3:
                    section.append(f"- *... and {len(vulnerable_dependency_info) - 3} more*")
            
            section.append("")
        else:
            section.append("#### ‚úÖ Dependency Analysis\n")
            section.append(f"All {total_deps} dependencies appear secure.\n")
        
        return section

    def _generate_remediation_steps(self, vulnerabilities: List[Dict], package_name: str) -> List[str]:
        """Generate remediation steps for vulnerabilities."""
        remediation = ["**üîß Remediation Steps:**\n"]
        
        # Collect all fixed versions
        all_fixed_versions = []
        for vuln in vulnerabilities:
            fixed_versions = vuln.get('fixed_versions', [])
            all_fixed_versions.extend(fixed_versions)
        
        if all_fixed_versions:
            # Try to find the minimum safe version
            try:
                # Simple version sorting (may not be perfect for all cases)
                sorted_versions = sorted(set(all_fixed_versions), key=lambda v: [int(x) for x in v.split('.') if x.isdigit()])
                min_safe_version = sorted_versions[0]
                
                remediation.append(f"1. **Upgrade to version {min_safe_version} or later:**")
                remediation.append(f"   ```bash")
                remediation.append(f"   pip install '{package_name}>={min_safe_version}'")
                remediation.append(f"   ```")
            except Exception:
                remediation.append(f"1. **Upgrade to the latest version:**")
                remediation.append(f"   ```bash")
                remediation.append(f"   pip install --upgrade {package_name}")
                remediation.append(f"   ```")
        else:
            remediation.append(f"1. **Upgrade to the latest version:**")
            remediation.append(f"   ```bash")
            remediation.append(f"   pip install --upgrade {package_name}")
            remediation.append(f"   ```")
        
        remediation.append("2. **Test your application** after the upgrade")
        remediation.append("3. **Update your requirements.txt** or dependency file")
        remediation.append("")
        
        return remediation

    def _generate_recommendations(self, scan_results: List[Dict]) -> str:
        """Generate recommendations section."""
        recommendations = ["## üí° Recommendations\n"]
        
        # Count issues
        total_vulns = sum(len(r.get('vulnerabilities', [])) for r in scan_results)
        critical_vulns = sum(len([v for v in r.get('vulnerabilities', []) if v.get('severity') == 'Critical']) for r in scan_results)
        high_vulns = sum(len([v for v in r.get('vulnerabilities', []) if v.get('severity') == 'High']) for r in scan_results)
        
        reputation_issues = sum(1 for r in scan_results if r.get('reputation', {}).get('risk_level') in ['High', 'Medium'])
        dependency_issues = sum(1 for r in scan_results if r.get('dependencies', {}).get('vulnerable_dependency_count', 0) > 0)
        
        if total_vulns > 0:
            recommendations.append("### üö® Immediate Actions")
            
            if critical_vulns > 0:
                recommendations.append(f"1. **URGENT:** Address {critical_vulns} critical vulnerabilities immediately")
            if high_vulns > 0:
                recommendations.append(f"2. **HIGH PRIORITY:** Address {high_vulns} high-severity vulnerabilities")
            
            recommendations.append("3. **Update vulnerable packages** to the recommended versions")
            recommendations.append("4. **Test your application** thoroughly after updates")
            recommendations.append("")
        
        if reputation_issues > 0 or dependency_issues > 0:
            recommendations.append("### ‚ö†Ô∏è Security Hygiene")
            
            if reputation_issues > 0:
                recommendations.append(f"1. **Review {reputation_issues} packages** with reputation concerns")
            if dependency_issues > 0:
                recommendations.append(f"2. **Audit dependency chains** for {dependency_issues} packages with vulnerable dependencies")
            
            recommendations.append("")
        
        recommendations.append("### üõ°Ô∏è Long-term Security")
        recommendations.append("1. **Implement automated security scanning** in your CI/CD pipeline")
        recommendations.append("2. **Regular dependency updates** - schedule monthly reviews")
        recommendations.append("3. **Dependency pinning** for production deployments")
        recommendations.append("4. **Security monitoring** - subscribe to security advisories")
        recommendations.append("5. **Principle of least privilege** - minimize package dependencies")
        
        return "\n".join(recommendations)