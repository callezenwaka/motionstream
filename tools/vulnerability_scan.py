# tools/vulnerability_scan.py
from typing import Any, Optional, List, Dict, Tuple
from smolagents.tools import Tool
import requests
from packaging import version
import json
import time

class ScanTool(Tool):
    name = "vulnerability_scanner"
    description = "Scans Python packages for known security vulnerabilities using the OSV database. Returns detailed vulnerability information including severity, affected versions, and fixes."
    inputs = {
        'package_name': {'type': 'string', 'description': 'The name of the Python package to scan for vulnerabilities.'},
        'package_version': {'type': 'string', 'description': 'Optional specific version to check. If not provided, will attempt to detect installed version.', 'required': False, 'nullable': True}
    }
    output_type = "string"

    def __init__(self, base_url: str = "https://api.osv.dev", **kwargs):
        super().__init__()
        self.base_url = base_url
        
        # Check required dependencies
        try:
            import requests
            from packaging import version
        except ImportError as e:
            raise ImportError(
                "You must install packages `requests` and `packaging` to run this tool: run `pip install requests packaging`."
            ) from e
            
        # Initialize session for API requests
        self.session = requests.Session()
        self.session.timeout = 30

    def forward(self, package_name: str, package_version: Optional[str] = None) -> str:
        """
        Scan a Python package for vulnerabilities.
        
        Args:
            package_name: Name of the package to scan
            package_version: Specific version to check (optional)
            
        Returns:
            Formatted string with vulnerability information
        """
        try:
            vulnerabilities = self._scan_vulnerabilities(package_name, package_version)
            return self._format_results(package_name, package_version, vulnerabilities)
        except Exception as e:
            return f"Error scanning {package_name}: {str(e)}"

    def _scan_vulnerabilities(self, package_name: str, package_version: str = None) -> List[Dict]:
        """Core vulnerability scanning logic."""
        # If no version provided, try to get installed version
        if not package_version:
            try:
                import pkg_resources
                package_version = pkg_resources.get_distribution(package_name).version
            except Exception:
                pass  # Continue without version
        
        # Query OSV database with pagination
        osv_vulnerabilities = self._query_osv_with_pagination(package_name, package_version)
        
        # Process and enrich vulnerability data
        processed_vulnerabilities = []
        for vuln in osv_vulnerabilities:
            processed_vuln = self._process_osv_vulnerability(vuln, package_name, package_version)
            if processed_vuln:
                processed_vulnerabilities.append(processed_vuln)
        
        # Sort by severity
        severity_order = {"Critical": 0, "High": 1, "Medium": 2, "Low": 3, "Unknown": 4}
        processed_vulnerabilities.sort(
            key=lambda v: severity_order.get(v.get('severity', 'Unknown'), 5)
        )
        
        return processed_vulnerabilities

    def _query_osv_with_pagination(self, package_name: str, package_version: str = None) -> List[Dict]:
        """Query OSV API with proper pagination support."""
        all_vulnerabilities = []
        page_token = None
        
        while True:
            # Prepare query payload
            query_data = {
                "package": {
                    "name": package_name,
                    "ecosystem": "PyPI"  # Case-sensitive
                }
            }
            
            if package_version:
                query_data["version"] = package_version
            
            if page_token:
                query_data["page_token"] = page_token
            
            try:
                response = self.session.post(
                    f"{self.base_url}/v1/query",
                    json=query_data,
                    timeout=30
                )
                response.raise_for_status()
                data = response.json()
                
                # Extract vulnerabilities from this page
                page_vulns = data.get("vulns", [])
                all_vulnerabilities.extend(page_vulns)
                
                # Check for pagination
                page_token = data.get("next_page_token")
                if not page_token:
                    break
                    
                # Small delay between paginated requests
                time.sleep(0.1)
                
            except requests.exceptions.RequestException as e:
                raise Exception(f"Error querying OSV API: {e}")
        
        return all_vulnerabilities

    def _process_osv_vulnerability(self, vuln: Dict, package_name: str, 
                                 package_version: str = None) -> Optional[Dict]:
        """Process raw OSV vulnerability into standardized format."""
        try:
            # Extract basic information
            vulnerability = {
                "id": vuln.get("id"),
                "summary": vuln.get("summary", "No summary available"),
                "details": vuln.get("details", ""),
                "published_date": vuln.get("published"),
                "modified_date": vuln.get("modified"),
                "source": "OSV",
                "references": []
            }
            
            # Extract references
            for ref in vuln.get("references", []):
                ref_info = {
                    "url": ref.get("url"),
                    "type": ref.get("type", "UNKNOWN")
                }
                vulnerability["references"].append(ref_info)
            
            # Process affected packages and version ranges
            affected_versions = []
            fixed_versions = []
            severity = "Unknown"
            
            for affected in vuln.get("affected", []):
                pkg = affected.get("package", {})
                
                # Check if this affects our package
                if pkg.get("name") != package_name:
                    continue
                    
                # Extract version information
                for version_range in affected.get("ranges", []):
                    range_type = version_range.get("type")
                    
                    if range_type == "SEMVER":
                        # Handle semantic version ranges
                        for event in version_range.get("events", []):
                            if event.get("introduced"):
                                if event["introduced"] != "0":
                                    affected_versions.append(f">={event['introduced']}")
                            if event.get("fixed"):
                                affected_versions.append(f"<{event['fixed']}")
                                fixed_versions.append(event["fixed"])
                
                # Extract specific affected versions
                specific_versions = affected.get("versions", [])
                if specific_versions:
                    vulnerability["specific_affected_versions"] = specific_versions
                
                # Extract severity information
                ecosystem_specific = affected.get("ecosystem_specific", {})
                if "severity" in ecosystem_specific:
                    severity = self._normalize_severity(ecosystem_specific["severity"])
            
            # Check if the specified version is affected
            if package_version and affected_versions:
                if not self._is_version_affected(package_version, affected_versions):
                    return None  # This version is not affected
            
            vulnerability["affected_versions"] = affected_versions
            vulnerability["fixed_versions"] = fixed_versions
            vulnerability["severity"] = severity
            
            # Extract CVSS scores if available
            if "severity" in vuln:
                cvss_info = self._extract_cvss_info(vuln["severity"])
                vulnerability.update(cvss_info)
            
            return vulnerability
            
        except Exception as e:
            return None

    def _extract_cvss_info(self, severity_data: List[Dict]) -> Dict:
        """Extract CVSS score information from OSV severity data."""
        cvss_info = {}
        
        for severity_item in severity_data:
            if severity_item.get("type") == "CVSS_V3":
                score = severity_item.get("score")
                if score:
                    cvss_info["cvss_v3_score"] = score
                    cvss_info["cvss_v3_vector"] = severity_item.get("vector", "")
                    
                    # Convert score to severity if not already set
                    if "severity" not in cvss_info:
                        cvss_info["severity"] = self._get_severity_from_score(score)
        
        return cvss_info

    def _normalize_severity(self, severity_str: str) -> str:
        """Normalize severity strings to standard values."""
        severity_upper = severity_str.upper()
        if severity_upper in ["CRITICAL", "HIGH", "MEDIUM", "LOW"]:
            return severity_upper.title()
        elif severity_upper in ["MODERATE"]:
            return "Medium"
        else:
            return "Unknown"

    def _is_version_affected(self, package_version: str, affected_versions: List[str]) -> bool:
        """Check if a version is affected by version constraints."""
        if not affected_versions:
            return True  # If no constraints, assume affected
        
        try:
            package_ver = version.parse(package_version)
            
            for constraint in affected_versions:
                constraint = constraint.strip()
                
                if constraint.startswith(">="):
                    if package_ver < version.parse(constraint[2:]):
                        return False
                elif constraint.startswith("<="):
                    if package_ver > version.parse(constraint[2:]):
                        return False
                elif constraint.startswith(">"):
                    if package_ver <= version.parse(constraint[1:]):
                        return False
                elif constraint.startswith("<"):
                    if package_ver >= version.parse(constraint[1:]):
                        return False
            
            return True
            
        except Exception:
            return True  # Assume affected if parsing fails

    def _get_severity_from_score(self, base_score: float) -> str:
        """Convert a CVSS base score to a severity rating."""
        try:
            score = float(base_score)
            if score >= 9.0:
                return "Critical"
            elif score >= 7.0:
                return "High"
            elif score >= 4.0:
                return "Medium"
            elif score > 0.0:
                return "Low"
            else:
                return "Unknown"
        except (ValueError, TypeError):
            return "Unknown"

    def _format_results(self, package_name: str, package_version: Optional[str], 
                       vulnerabilities: List[Dict]) -> str:
        """Format vulnerability results into a readable string."""
        if not vulnerabilities:
            version_info = f" version {package_version}" if package_version else ""
            return f"✅ No vulnerabilities found for {package_name}{version_info}"
        
        # Build header
        version_info = f" version {package_version}" if package_version else ""
        result = f"🚨 **Vulnerability Scan Results for {package_name}{version_info}**\n"
        result += f"Found {len(vulnerabilities)} vulnerabilities\n\n"
        
        # Group by severity for summary
        severity_counts = {}
        for vuln in vulnerabilities:
            sev = vuln.get('severity', 'Unknown')
            severity_counts[sev] = severity_counts.get(sev, 0) + 1
        
        result += "**Severity Summary:**\n"
        for severity in ["Critical", "High", "Medium", "Low", "Unknown"]:
            if severity in severity_counts:
                emoji = {"Critical": "🔴", "High": "🟠", "Medium": "🟡", "Low": "🔵", "Unknown": "⚪"}.get(severity, "⚪")
                result += f"{emoji} {severity}: {severity_counts[severity]}\n"
        result += "\n---\n\n"
        
        # Detail each vulnerability
        for i, vuln in enumerate(vulnerabilities, 1):
            severity = vuln.get('severity', 'Unknown')
            emoji = {"Critical": "🔴", "High": "🟠", "Medium": "🟡", "Low": "🔵", "Unknown": "⚪"}.get(severity, "⚪")
            
            result += f"## {i}. {emoji} {vuln.get('id', 'Unknown ID')} - {severity}\n\n"
            result += f"**Summary:** {vuln.get('summary', 'No summary available')}\n\n"
            
            if vuln.get('details'):
                # Truncate very long details
                details = vuln['details']
                if len(details) > 500:
                    details = details[:500] + "..."
                result += f"**Details:** {details}\n\n"
            
            if vuln.get('affected_versions'):
                result += f"**Affected Versions:** {', '.join(vuln['affected_versions'])}\n\n"
            
            if vuln.get('fixed_versions'):
                result += f"**Fixed In:** {', '.join(vuln['fixed_versions'])}\n\n"
            
            if vuln.get('cvss_v3_score'):
                result += f"**CVSS v3 Score:** {vuln['cvss_v3_score']}\n\n"
            
            if vuln.get('references'):
                result += "**References:**\n"
                for ref in vuln['references'][:3]:  # Limit to first 3 references
                    result += f"- [{ref.get('type', 'Link')}]({ref.get('url', '#')})\n"
                result += "\n"
            
            if vuln.get('published_date'):
                pub_date = vuln['published_date'][:10] if len(vuln['published_date']) > 10 else vuln['published_date']
                result += f"**Published:** {pub_date}\n\n"
            
            result += "---\n\n"
        
        return result