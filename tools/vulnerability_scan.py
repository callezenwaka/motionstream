# tools/vulnerability_scan.py
import requests
from packaging import version
import json
import time

def scan_vulnerabilities(package_name, package_version=None):
    """
    Scan a Python package for known security vulnerabilities.
    
    Args:
        package_name: Name of the package to scan
        package_version: Specific version to check (optional)
        use_osv_only: Whether to use only OSV database (skips NVD due to rate
        
    Returns:
        List of vulnerability dictionaries
    """
    print(f"Scanning {package_name}{f'=={package_version}' if package_version else ''}...")
    
    # If no version provided, try to get installed version
    if not package_version:
        try:
            import pkg_resources
            package_version = pkg_resources.get_distribution(package_name).version
            print(f"Using installed version: {package_version}")
        except Exception:
            print("Could not determine installed version")
    
    # Combine vulnerabilities from multiple sources
    all_vulnerabilities = []
    
    # Check NVD database for CVEs
    # nvd_vulnerabilities = query_nvd_database(package_name, package_version)
    # all_vulnerabilities.extend(nvd_vulnerabilities)
    
    # Check OSV database (Open Source Vulnerabilities)
    osv_vulnerabilities = query_osv_database(package_name, package_version)
    all_vulnerabilities.extend(osv_vulnerabilities)
    
    # Check PyPI Security Advisories
    pypi_vulnerabilities = check_pypi_advisories(package_name, package_version)
    all_vulnerabilities.extend(pypi_vulnerabilities)
    
    # Deduplicate vulnerabilities (based on CVE ID or similar identifier)
    unique_vulnerabilities = {}
    for vuln in all_vulnerabilities:
        # Use CVE ID as key if available, otherwise use a combination of fields
        key = vuln.get('cve_id') or vuln.get('id') or (vuln.get('source') + vuln.get('summary', '')[:50])
        
        if key not in unique_vulnerabilities:
            unique_vulnerabilities[key] = vuln
    
    # Enrich vulnerability data with severity information if missing
    enriched_vulnerabilities = []
    for vuln in unique_vulnerabilities.values():
        if 'severity' not in vuln and 'base_score' in vuln:
            vuln['severity'] = get_severity_from_score(vuln['base_score'])
        enriched_vulnerabilities.append(vuln)
    
    # Sort vulnerabilities by severity (Critical first)
    severity_order = {"Critical": 0, "High": 1, "Medium": 2, "Low": 3, "Unknown": 4}
    sorted_vulnerabilities = sorted(
        enriched_vulnerabilities,
        key=lambda v: severity_order.get(v.get('severity', 'Unknown'), 5)
    )
    
    return sorted_vulnerabilities

def query_nvd_database(package_name, package_version=None, api_key=None):
    """Query the National Vulnerability Database (NVD) for CVEs affecting this package."""
    vulnerabilities = []
    
    try:
        # NVD API endpoint
        # https://nvd.nist.gov/developers/vulnerabilities
        url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        
        # Prepare headers - API key is now required for better rate limits
        headers = {
            "User-Agent": "Python-CVE-Checker/1.0"
        }
        if api_key:
            headers["apiKey"] = api_key
        
        # CPE format is more reliable than keyword search
        # Format: cpe:2.3:a:python:requests:*:*:*:*:*:*:*:*
        # But we'll still use keyword search as fallback
        params = {
            "keywordSearch": package_name,  # Removed "python" prefix as it might be too restrictive
            "keywordExactMatch": False
        }
        
        # Rate limiting to avoid hitting NVD API limits
        # Without API key: 5 requests per 30 seconds (6 seconds between requests)
        # With API key: 50 requests per 30 seconds (0.6 seconds between requests)
        time.sleep(6 if not api_key else 0.6)
        
        response = requests.get(url, params=params, headers=headers, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        # Rest of the function remains the same
        if "vulnerabilities" in data:
            for vuln_data in data["vulnerabilities"]:
                cve = vuln_data.get("cve", {})
                
                # Extract basic CVE info
                cve_id = cve.get("id")
                
                # Extract descriptions
                descriptions = cve.get("descriptions", [])
                description = next((d.get("value") for d in descriptions if d.get("lang") == "en"), "No description available")
                
                # Extract CVSS data
                metrics = cve.get("metrics", {})
                cvss_v31 = metrics.get("cvssMetricV31", [])
                cvss_v30 = metrics.get("cvssMetricV30", [])
                cvss_v2 = metrics.get("cvssMetricV2", [])
                
                # Try to get CVSS data from v3.1, v3.0, or v2
                cvss_data = None
                base_score = 0
                
                if cvss_v31:
                    cvss_data = cvss_v31[0].get("cvssData", {})
                    base_score = cvss_data.get("baseScore", 0)
                elif cvss_v30:
                    cvss_data = cvss_v30[0].get("cvssData", {})
                    base_score = cvss_data.get("baseScore", 0)
                elif cvss_v2:
                    cvss_data = cvss_v2[0].get("cvssData", {})
                    base_score = cvss_data.get("baseScore", 0)
                
                # Check if this vulnerability affects the specified package
                if affects_python_package(cve, package_name, package_version):
                    vulnerability = {
                        "cve_id": cve_id,
                        "summary": description,
                        "base_score": base_score,
                        "severity": get_severity_from_score(base_score),
                        "vector_string": cvss_data.get("vectorString", "") if cvss_data else "",
                        "published_date": vuln_data.get("published"),
                        "last_modified_date": vuln_data.get("lastModified"),
                        "source": "NVD"
                    }
                    
                    # Try to extract fixed versions if available
                    fixed_versions = extract_fixed_versions(cve)
                    if fixed_versions:
                        vulnerability["fixed_versions"] = fixed_versions
                    
                    vulnerabilities.append(vulnerability)
                
        return vulnerabilities
    
    except Exception as e:
        print(f"Error querying NVD: {e}")
        return []
    
def query_osv_database(package_name, package_version=None):
    """Query the OSV database for vulnerabilities affecting this package."""
    vulnerabilities = []
    
    try:
        # OSV API endpoint
        url = "https://api.osv.dev/v1/query"
        
        # Prepare query data
        query_data = {
            "package": {
                "name": package_name,
                "ecosystem": "PyPI"
            }
        }
        
        # Add version if specified
        if package_version:
            query_data["version"] = package_version
        
        # Make the request
        response = requests.post(url, json=query_data, timeout=10)
        response.raise_for_status()
        data = response.json()
        print(f"data: {data}")
        
        # Process vulnerabilities
        for vuln in data.get("vulns", []):
            # Extract affected versions
            affected_versions = []
            fixed_versions = []
            
            for affected in vuln.get("affected", []):
                if affected.get("package", {}).get("name") == package_name:
                    # Get affected version ranges
                    for affected_range in affected.get("ranges", []):
                        if affected_range.get("type") == "SEMVER":
                            for event in affected_range.get("events", []):
                                if event.get("introduced"):
                                    affected_versions.append(f">={event.get('introduced')}")
                                if event.get("fixed"):
                                    affected_versions.append(f"<{event.get('fixed')}")
                                    fixed_versions.append(event.get("fixed"))
            
            # Check if version is affected (if specified)
            if package_version and not is_version_affected(package_version, affected_versions):
                continue
            
            # Extract references
            references = [ref.get("url") for ref in vuln.get("references", [])]
            
            # Create vulnerability record
            vulnerability = {
                "id": vuln.get("id"),
                "summary": vuln.get("summary"),
                "details": vuln.get("details"),
                "affected_versions": affected_versions,
                "fixed_versions": fixed_versions,
                "references": references,
                "published_date": vuln.get("published"),
                "modified": vuln.get("modified"),
                "source": "OSV"
            }
            
            # Add severity if available
            if "severity" in vuln:
                vulnerability["severity"] = vuln.get("severity")
            
            vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    except Exception as e:
        print(f"Error querying OSV database: {e}")
        return []

def check_pypi_advisories(package_name, package_version=None):
    """Check PyPI for security advisories."""
    vulnerabilities = []
    
    try:
        # Get package information from PyPI
        url = f"https://pypi.org/pypi/{package_name}/json"
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        # Check release history for security advisories
        if package_version:
            current_version = version.parse(package_version)
            releases = data.get("releases", {})
            
            # Look for security fixes in newer versions
            for rel_version, rel_files in releases.items():
                try:
                    # Skip older or current versions
                    if version.parse(rel_version) <= current_version:
                        continue
                    
                    # Look for security-related comments in release files
                    for rel_file in rel_files:
                        comment = rel_file.get("comment_text", "").lower()
                        has_security_terms = any(term in comment for term in 
                                                ["security", "vulnerability", "cve", "fix", "issue"])
                        
                        if has_security_terms:
                            # Found a potential security fix
                            vulnerability = {
                                "id": f"PYPI-{package_name}-{rel_version}",
                                "summary": f"Potential security fix in version {rel_version}",
                                "details": comment,
                                "fixed_versions": [rel_version],
                                "source": "PyPI",
                                "severity": "Unknown"  # Can't determine from PyPI alone
                            }
                            vulnerabilities.append(vulnerability)
                            break
                except Exception:
                    # Skip versions that can't be parsed
                    continue
    
    except Exception as e:
        print(f"Error checking PyPI advisories: {e}")
    
    return vulnerabilities

def affects_python_package(cve, package_name, package_version=None):
    """
    Determine if a CVE affects the specified Python package and version.
    This is a simplified implementation that can be enhanced.
    """
    # Check the description for package name mentions
    descriptions = cve.get("descriptions", [])
    description_text = " ".join(d.get("value", "") for d in descriptions).lower()
    
    if f"python {package_name}".lower() in description_text or f"package {package_name}".lower() in description_text:
        # If version is specified, check if it's mentioned in the description
        if package_version:
            if package_version in description_text:
                return True
            
            # Check configuration nodes (CPE matches)
            for config in cve.get("configurations", []):
                for node in config.get("nodes", []):
                    for cpe_match in node.get("cpeMatch", []):
                        criteria = cpe_match.get("criteria", "").lower()
                        if package_name.lower() in criteria and package_version in criteria:
                            return True
            
            # More sophisticated version range checking could be implemented here
            return False
        
        # If no version specified, return True if package is mentioned
        return True
    
    # Check vulnerability references for package mentions
    references = cve.get("references", [])
    for ref in references:
        if package_name in ref.get("url", "").lower():
            return True
    
    return False

def extract_fixed_versions(cve):
    """
    Try to extract fixed versions from CVE data.
    This is a simplified implementation that can be enhanced.
    """
    fixed_versions = []
    
    # Check references for GitHub commits or releases
    references = cve.get("references", [])
    for ref in references:
        url = ref.get("url", "")
        # Check for GitHub release
        if "github.com" in url and "/releases/tag/" in url:
            version_str = url.split("/releases/tag/")[1].strip()
            fixed_versions.append(version_str)
    
    # Check description for version mentions
    descriptions = cve.get("descriptions", [])
    for desc in descriptions:
        text = desc.get("value", "")
        if "fixed in version" in text.lower():
            # Try to extract version numbers
            import re
            versions = re.findall(r"version (\d+\.\d+\.\d+)", text)
            fixed_versions.extend(versions)
    
    return list(set(fixed_versions))  # Remove duplicates

def is_version_affected(package_version, affected_versions):
    """
    Check if a version is affected by a set of version constraints.
    
    Args:
        package_version: The version to check
        affected_versions: List of version constraints (e.g., [">=1.0.0", "<2.0.0"])
    
    Returns:
        True if the version is affected, False otherwise
    """
    if not affected_versions:
        return True  # If no constraints, assume affected
    
    try:
        package_ver = version.parse(package_version)
        
        for constraint in affected_versions:
            op = constraint[:2]
            ver_str = constraint[2:]
            
            # Handle different operators
            if op == ">=":
                if package_ver < version.parse(ver_str):
                    return False
            elif op == "<=":
                if package_ver > version.parse(ver_str):
                    return False
            elif op == "==":
                if package_ver != version.parse(ver_str):
                    return False
            elif op == "!=":
                if package_ver == version.parse(ver_str):
                    return False
            elif op.startswith(">"):
                if package_ver <= version.parse(ver_str[1:]):
                    return False
            elif op.startswith("<"):
                if package_ver >= version.parse(ver_str[1:]):
                    return False
        
        # If all constraints are satisfied, the version is affected
        return True
    
    except Exception:
        # If there's an error parsing versions, assume affected
        return True

def get_severity_from_score(base_score):
    """
    Convert a CVSS base score to a severity rating.
    
    Args:
        base_score: CVSS base score (0.0-10.0)
        
    Returns:
        Severity rating: Critical, High, Medium, Low, or Unknown
    """
    try:
        score = float(base_score)
        if score >= 9.0:
            return "Critical"
        elif score >= 7.0:
            return "High"
        elif score >= 4.0:
            return "Medium"
        elif score > 0.0:
            return "Low"
        else:
            return "Unknown"
    except (ValueError, TypeError):
        return "Unknown"